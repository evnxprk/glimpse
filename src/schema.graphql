scalar DateTime
scalar JSON
scalar Upload

directive @auth(action: String, subject: String) on FIELD_DEFINITION

"""
Input type used for pagination in multi-document searches. Offset-based OR cursor-based pagination can be
used, or both. This is fed to Prisma. https://www.prisma.io/docs/concepts/components/prisma-client/pagination
"""
input Pagination {
    skip: Int
    take: Int!
    cursor: ID
}

type Query {
    """
    Get a list of users which the user currently has access to read.
    """
    users(pagination: Pagination): [User!]! @auth(action: "read", subject: "User")
    """
    Get a single user given their ID, or null if that user does not exist.
    """
    user(id: ID!): User @auth(action: "read", subject: "User")
}

#type Mutation {
#
#}

# Basic types #

type AccessLog {
    id: ID! @auth(action: "read", subject: "AccessLog")
    user: User @auth(action: "read", subject: "AccessLog")
    service: String @auth(action: "read", subject: "AccessLog")
    timestamp: DateTime @auth(action: "read", subject: "AccessLog")
    ip: String @auth(action: "read", subject: "AccessLog")
}

type AlertLog {
    id: ID! @auth(action: "read", subject: "AlertLog")
    message: String @auth(action: "read", subject: "AlertLog")
    severity: String @auth(action: "read", subject: "AlertLog")
    timestamp: DateTime @auth(action: "read", subject: "AlertLog")
}

type Asset {
    id: ID! @auth(action: "read", subject: "Asset")
    tag: Int @auth(action: "read", subject: "Asset")
    name: String! @auth(action: "read", subject: "Asset")
    lastKnownLocation: String @auth(action: "read", subject: "Asset")
    lastKnownHandler: User @auth(action: "read", subject: "Asset")
    isLost: Boolean @auth(action: "read", subject: "Asset")
    notes: String @auth(action: "read", subject: "Asset")
    purchasePrice: Int @auth(action: "read", subject: "Asset")
    purchaseLocation: String @auth(action: "read", subject: "Asset")
    purchaseDate: DateTime @auth(action: "read", subject: "Asset")
    modelNumber: String @auth(action: "read", subject: "Asset")
    serialNumber: String @auth(action: "read", subject: "Asset")
    parent: Asset @auth(action: "read", subject: "Asset")
    children: [Asset!] @auth(action: "read", subject: "Asset")
}

type AuditLog {
    id: ID! @auth(action: "read", subject: "AuditLog")
    user: User @auth(action: "read", subject: "AuditLog")
    timestamp: DateTime @auth(action: "read", subject: "AuditLog")
    modificationType: String @auth(action: "read", subject: "AuditLog")
    modifiedTable: String @auth(action: "read", subject: "AuditLog")
    modifiedField: String @auth(action: "read", subject: "AuditLog")
    previousValue: String @auth(action: "read", subject: "AuditLog")
    comment: String @auth(action: "read", subject: "AuditLog")
    metadata: JSON @auth(action: "read", subject: "AuditLog")
}

type BlogPost {
    id: ID! @auth(action: "read", subject: "BlogPost")
    postedAt: DateTime @auth(action: "read", subject: "BlogPost")
    content: String @auth(action: "read", subject: "BlogPost")
    author: Person @auth(action: "read", subject: "BlogPost")
    authorDisplayName: String @auth(action: "read", subject: "BlogPost")
    title: String @auth(action: "read", subject: "BlogPost")
}

type Category {
    id: ID! @auth(action: "read", subject: "Category")
    name: String @auth(action: "read", subject: "Category")
    priority: Int @auth(action: "read", subject: "Category")
    parent: Category @auth(action: "read", subject: "Category")
    productions: [Production!] @auth(action: "read", subject: "Category")
}

type ContactSubmissionAssignee {
    id: ID! @auth(action: "read", subject: "ContactSubmissionAssignee")
    submission: ContactSubmission @auth(action: "read", subject: "ContactSubmissionAssignee")
    user: User @auth(action: "read", subject: "ContactSubmissionAssignee")
    timestamp: DateTime @auth(action: "read", subject: "ContactSubmissionAssignee")
}

type ContactSubmission {
    id: ID! @auth(action: "read", subject: "ContactSubmission")
    email: String @auth(action: "read", subject: "ContactSubmission")
    name: String @auth(action: "read", subject: "ContactSubmission")
    timestamp: DateTime @auth(action: "read", subject: "ContactSubmission")
    resolved: Boolean @auth(action: "read", subject: "ContactSubmission")
    additionalData: JSON @auth(action: "read", subject: "ContactSubmission")
    assignees: [ContactSubmissionAssignee!] @auth(action: "read", subject: "ContactSubmission")
}

type Credit {
    id: ID! @auth(action: "read", subject: "Credit")
    production: Production @auth(action: "read", subject: "Credit")
    person: Person @auth(action: "read", subject: "Credit")
    title: String @auth(action: "read", subject: "Credit")
    priority: Int @auth(action: "read", subject: "Credit")
}

type GroupPermission {
    id: ID! @auth(action: "read", subject: "GroupPermission")
    group: Group @auth(action: "read", subject: "GroupPermission")
    action: String @auth(action: "read", subject: "GroupPermission")
    subject: [String!] @auth(action: "read", subject: "GroupPermission")
    fields: [String!] @auth(action: "read", subject: "GroupPermission")
    conditions: JSON @auth(action: "read", subject: "GroupPermission")
    inverted: Boolean @auth(action: "read", subject: "GroupPermission")
    reason: String @auth(action: "read", subject: "GroupPermission")
}

type Group {
    id: ID! @auth(action: "read", subject: "Group")
    name: String @auth(action: "read", subject: "Group")
    parent: Group @auth(action: "read", subject: "Group")
    priority: Int @auth(action: "read", subject: "Group")
    permissions: [GroupPermission!] @auth(action: "read", subject: "Group")
    children: [Group!] @auth(action: "read", subject: "Group")
    users: [UserGroup!] @auth(action: "read", subject: "Group")
}

type Image {
    id: ID! @auth(action: "read", subject: "Image")
    name: String @auth(action: "read", subject: "Image")
    description: String @auth(action: "read", subject: "Image")
    path: String @auth(action: "read", subject: "Image")
    people: [PersonImage!] @auth(action: "read", subject: "Image")
    imageFor: [ProductionImage!] @auth(action: "read", subject: "Image")
    thumbnailFor: [Production!] @auth(action: "read", subject: "Image")
}

type Person {
    id: ID! @auth(action: "read", subject: "Person")
    name: String @auth(action: "read", subject: "Person")
    pronouns: String @auth(action: "read", subject: "Person")
    graduation: DateTime @auth(action: "read", subject: "Person")
    start: DateTime @auth(action: "read", subject: "Person")
    end: DateTime @auth(action: "read", subject: "Person")
    description: String @auth(action: "read", subject: "Person")
    images: [PersonImage!] @auth(action: "read", subject: "Person")
    blogPosts: [BlogPost!] @auth(action: "read", subject: "Person")
    credits: [Credit!] @auth(action: "read", subject: "Person")
    roles: [Role!] @auth(action: "read", subject: "Person")
    users: [User!] @auth(action: "read", subject: "Person")
}

type PersonImage {
    id: ID! @auth(action: "read", subject: "PersonImage")
    image: Image @auth(action: "read", subject: "PersonImage")
    person: Person @auth(action: "read", subject: "PersonImage")
    priority: Int @auth(action: "read", subject: "PersonImage")
}

type ProductionImage {
    id: ID! @auth(action: "read", subject: "ProductionImage")
    production: Production @auth(action: "read", subject: "ProductionImage")
    image: Image @auth(action: "read", subject: "ProductionImage")
    priority: Int @auth(action: "read", subject: "ProductionImage")
}

type ProductionRSVP {
    id: ID! @auth(action: "read", subject: "ProductionRSVP")
    production: Production @auth(action: "read", subject: "ProductionRSVP")
    user: User @auth(action: "read", subject: "ProductionRSVP")
    willAttend: Boolean @auth(action: "read", subject: "ProductionRSVP")
    notes: String @auth(action: "read", subject: "ProductionRSVP")
}

type ProductionTag {
    id: ID! @auth(action: "read", subject: "ProductionTag")
    production: Production @auth(action: "read", subject: "ProductionTag")
    tag: String @auth(action: "read", subject: "ProductionTag")
}

type ProductionVideo {
    id: ID! @auth(action: "read", subject: "ProductionVideo")
    production: Production @auth(action: "read", subject: "ProductionVideo")
    video: Video @auth(action: "read", subject: "ProductionVideo")
    priority: Int @auth(action: "read", subject: "ProductionVideo")
}

type Production {
    id: ID! @auth(action: "read", subject: "Production")
    name: String @auth(action: "read", subject: "Production")
    description: String @auth(action: "read", subject: "Production")
    startTime: DateTime @auth(action: "read", subject: "Production")
    endTime: DateTime @auth(action: "read", subject: "Production")
    isLive: Boolean @auth(action: "read", subject: "Production")
    category: Category @auth(action: "read", subject: "Production")
    closetLocation: String @auth(action: "read", subject: "Production")
    eventLocation: String @auth(action: "read", subject: "Production")
    teamNotes: String @auth(action: "read", subject: "Production")
    discordServer: String @auth(action: "read", subject: "Production")
    discordChannel: String @auth(action: "read", subject: "Production")
    thumbnail: Image @auth(action: "read", subject: "Production")
    closetTime: DateTime @auth(action: "read", subject: "Production")
    images: [ProductionImage!] @auth(action: "read", subject: "Production")
    rsvps: [ProductionRSVP!] @auth(action: "read", subject: "Production")
    tags: [ProductionTag!] @auth(action: "read", subject: "Production")
    videos: [ProductionVideo!] @auth(action: "read", subject: "Production")
}

type Redirect {
    id: ID! @auth(action: "read", subject: "Redirect")
    key: String @auth(action: "read", subject: "Redirect")
    location: String @auth(action: "read", subject: "Redirect")
    expires: DateTime @auth(action: "read", subject: "Redirect")
}

type Role {
    id: ID! @auth(action: "read", subject: "Role")
    person: Person @auth(action: "read", subject: "Role")
    name: String @auth(action: "read", subject: "Role")
    startTime: DateTime @auth(action: "read", subject: "Role")
    endTime: DateTime @auth(action: "read", subject: "Role")
    priority: Int @auth(action: "read", subject: "Role")
}

type UserGroup {
    id: ID! @auth(action: "read", subject: "UserGroup")
    user: User @auth(action: "read", subject: "UserGroup")
    group: Group @auth(action: "read", subject: "UserGroup")
}

type UserPermission {
    id: ID! @auth(action: "read", subject: "UserPermission")
    user: User @auth(action: "read", subject: "UserPermission")
    action: String @auth(action: "read", subject: "UserPermission")
    subject: [String!] @auth(action: "read", subject: "UserPermission")
    fields: [String!] @auth(action: "read", subject: "UserPermission")
    conditions: JSON @auth(action: "read", subject: "UserPermission")
    inverted: Boolean @auth(action: "read", subject: "UserPermission")
    reason: String @auth(action: "read", subject: "UserPermission")
}

type User {
    id: ID! @auth(action: "read", subject: "User")
    username: String @auth(action: "read", subject: "User")
    mail: String @auth(action: "read", subject: "User")
    person: Person @auth(action: "read", subject: "User")
    discord: String @auth(action: "read", subject: "User")
    joined: DateTime @auth(action: "read", subject: "User")
    permissions: [UserPermission!] @auth(action: "read", subject: "User")
    groups: [UserGroup!] @auth(action: "read", subject: "User")
    accessLogs: [AccessLog!] @auth(action: "read", subject: "User")
    auditLogs: [AuditLog!] @auth(action: "read", subject: "User")
    assignedContactSubmissions: [ContactSubmissionAssignee!] @auth(action: "read", subject: "User")
    productionRsvps: [ProductionRSVP!] @auth(action: "read", subject: "User")
    voteResponses: [VoteResponse!] @auth(action: "read", subject: "User")
    checkedOutAssets: [Asset!] @auth(action: "read", subject: "User")
}

input UserWriteInput {
    username: String
    mail: String
    person: ID
    discord: String
    password: String
}

type Video {
    id: ID! @auth(action: "read", subject: "Video")
    name: String @auth(action: "read", subject: "Video")
    format: String @auth(action: "read", subject: "Video")
    metadata: JSON @auth(action: "read", subject: "Video")
    videoFor: [ProductionVideo!] @auth(action: "read", subject: "Video")
}

type VoteResponse {
    id: ID! @auth(action: "read", subject: "VoteResponse")
    vote: Vote @auth(action: "read", subject: "VoteResponse")
    user: User @auth(action: "read", subject: "VoteResponse")
    timestamp: DateTime @auth(action: "read", subject: "VoteResponse")
}

type Vote {
    id: ID! @auth(action: "read", subject: "Vote")
    question: String @auth(action: "read", subject: "Vote")
    options: [String!] @auth(action: "read", subject: "Vote")
    expires: DateTime @auth(action: "read", subject: "Vote")
    description: String @auth(action: "read", subject: "Vote")
    responses: [VoteResponse!] @auth(action: "read", subject: "Vote")
}
